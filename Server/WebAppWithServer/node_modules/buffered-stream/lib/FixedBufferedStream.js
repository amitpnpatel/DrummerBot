// Generated by CoffeeScript 1.4.0
var BufferedStream, stream, util;

stream = require('stream');

util = require('util');

/*
`FixedBufferedStream([size])`
=============================

This class implement both the Readable and Writable Stream 
API. Data written to it are stored inside a buffer. The buffer 
is emited though a "data" event when it is about to 
get larger than a defined "size".

The buffer is defined with a fixed size. As a consequence, 
this implentation present the advantage of consuming a 
constant amount of memory over time.

In the event that the data written is larger than the 
defined size, the buffer mechanism is bypassed and the data 
is directly emited with the "data" event. 

Setting the "size" parameter to 0 will simply bypassed the bufferisation.

Usage
-----

To create a new instance:

```
var BufferedStream = require('buffered-stream/lib/FixedBufferedStream');
// or
var BufferedStream = require('buffered-stream').fixed();
```

To use it in pipe:

```
reader = fs.createStreamReader('/tmp/in');
buffer = buffered(4*1024*1024);
writer = fs.createStreamWriter('/tmp/out');
reader.pipe(buffer).pipe(writer);
```

Performances
------------

The results presented below are obtained by running `coffee samples/speed.coffee`.

Writting 100000 lines of 100 bytes (about 9.5 Mo)

```
0 b     : 2 s 54 ms 
64 b    : 1 s 927 ms 
128 b   : 1 s 798 ms 
256 b   : 1 s 283 ms 
512 b   : 817 ms 
1 Kb    : 576 ms 
1 Mb    : 293 ms 
4 Mb    : 283 ms 
16 Mb   : 273 ms 
64 Mb   : 273 ms 
128 Mb  : 274 ms
```

Writting 1000000 lines of 100 bytes (about 95 Mo)

```
0 b     : 20 s 454 ms 
64 b    : 20 s 548 ms 
128 b   : 15 s 754 ms 
256 b   : 12 s 803 ms 
512 b   : 7 s 626 ms 
1 Kb    : 5 s 189 ms 
1 Mb    : 2 s 514 ms 
4 Mb    : 2 s 610 ms 
16 Mb   : 2 s 771 ms 
64 Mb   : 2 s 758 ms 
128 Mb  : 2 s 750 ms
```

In this test, we are reading from a custom generator 
Readable Stream and writing to the file system. Since we 
are writing 100 bytes lines, a buffer of 0 byte or 64 byte
lead to the same internal behavior while a buffer of 128 bytes
use the internal buffer but lead to similar performances. Increasing
the buffer size increase performance until the buffer reach 1 Mo. After
that, performance stale. Notice that in our tests, a file Readable Stream write data 
as 1 Mo chunks as well.
*/


BufferedStream = function(size) {
  if (size == null) {
    size = 1024;
  }
  this.writable = true;
  this.readable = true;
  this.size = size;
  this.buffer = new Buffer(size);
  this.bufferPos = 0;
  return stream.call(this);
};

BufferedStream.prototype.__proto__ = stream.prototype;

BufferedStream.prototype.write = function(data) {
  var buffer, dataWritten;
  if (!Buffer.isBuffer(data)) {
    data = new Buffer(data);
  }
  if (data.length > this.size) {
    this.emit('data', data);
    return !this.paused;
  }
  dataWritten = Math.min(this.size - this.bufferPos, data.length);
  if (dataWritten !== 0) {
    data.copy(this.buffer, this.bufferPos, 0, dataWritten);
  }
  this.bufferPos += dataWritten;
  if (dataWritten !== data.length) {
    buffer = new Buffer(this.bufferPos);
    this.buffer.copy(buffer, 0, 0, this.bufferPos);
    this.emit('data', buffer);
    data.copy(this.buffer, 0, dataWritten, data.length);
    this.bufferPos = data.length - dataWritten;
    return !this.paused;
  }
  return true;
};

BufferedStream.prototype.pause = function(data) {
  return this.paused = true;
};

BufferedStream.prototype.resume = function(data) {
  this.paused = false;
  return this.emit('drain');
};

BufferedStream.prototype.end = function() {
  this.emit('data', this.buffer.slice(0, this.bufferPos));
  this.writable = false;
  this.readable = false;
  return this.emit('end');
};

module.exports = BufferedStream;
