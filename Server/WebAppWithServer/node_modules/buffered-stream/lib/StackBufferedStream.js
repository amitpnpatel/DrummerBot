// Generated by CoffeeScript 1.4.0
var BufferStream, Stream, util;

util = require('util');

Stream = require('stream');

/*

`StackBufferedStream([size])`
=============================

This class implement both the Readable and Writable Stream 
API. It provides the guaranty than no data will be written 
when the destination requested a pause. Data written to it 
are stored inside multiple buffers of a provided fixed length. 

In the event that the data written is larger than the 
defined size, the buffer mechanism is bypassed and the data 
is directly emited with the "data" event. 

Performances
------------

The results presented below are obtained by running `coffee samples/speed.coffee`.

Writting 100000 lines of 100 bytes (about 9.5 Mo)

```
0 b     : 2 s 146 ms 
64 b    : 2 s 172 ms 
128 b   : 2 s 155 ms 
256 b   : 1 s 256 ms 
512 b   : 749 ms 
1 Kb    : 565 ms 
1 Mb    : 333 ms 
4 Mb    : 341 ms 
16 Mb   : 342 ms 
64 Mb   : 350 ms 
128 Mb  : 351 ms
```

Writting 1000000 lines of 100 bytes (about 95 Mo)

```
0 b     : 20 s 636 ms 
64 b    : 20 s 217 ms 
128 b   : 21 s 749 ms 
256 b   : 12 s 769 ms 
512 b   : 7 s 520 ms 
1 Kb    : 5 s 452 ms 
1 Mb    : 3 s 193 ms 
4 Mb    : 3 s 218 ms 
16 Mb   : 3 s 326 ms 
64 Mb   : 3 s 415 ms 
128 Mb  : 3 s 368 ms
```
*/


BufferStream = function(size) {
  Stream.call(this);
  this.readable = true;
  this.writable = true;
  this.bufferSize = size != null ? parseInt(size, 10) : 1024 * 1024;
  this.paused = false;
  this.buffers = [];
  return this.stackSize = 1;
};

util.inherits(BufferStream, Stream);

/*
Emit "end" if the "end" function has been called and there is no more buffer to flush.
*/


BufferStream.prototype.flush = function() {
  var buffer, ended;
  ended = !this.writable;
  if (!ended && this.paused) {
    return;
  }
  if (!ended && this.buffers.length <= 1) {
    return this.emit('drain');
  }
  if ((ended && this.buffers.length) || this.buffers.length > 1) {
    buffer = this.buffers.shift();
    this.emit('data', buffer.slice(0, buffer.position));
  }
  if (ended && !this.buffers.length) {
    if (this.paused) {
      this.on('drain', function() {
        return this.emit('end');
      });
    } else {
      this.emit('end');
    }
    return;
  }
  return this.flush();
};

BufferStream.prototype.destroy = function() {
  return this.destroySoon();
};

BufferStream.prototype.destroySoon = function() {
  this.end();
  this.readable = false;
  return this.writable = false;
};

/*
Write API
drain  Emitted after a write() method was called that returned false to indicate that it is safe to write again
error  Emitted on error with the exception exception
close  Emitted when the underlying file descriptor has been closed
pipe    Emitted when the stream is passed to a readable stream's pipe method
*/


BufferStream.prototype.write = function(data, opt_encoding) {
  var buffer, encoding, flush;
  if (data) {
    flush = false;
    encoding = opt_encoding || 'utf8';
    if (!Buffer.isBuffer(data)) {
      data = new Buffer(data, encoding);
    }
    if (data.length > this.bufferSize) {
      this.emit('data', data);
      return !this.paused;
    }
    if (data.length > this.bufferSize) {
      throw new Error('Data length greater than buffer');
    }
    if (!this.buffers.length) {
      buffer = new Buffer(this.bufferSize);
      buffer.position = 0;
      this.buffers.push(buffer);
    } else {
      buffer = this.buffers[this.buffers.length - 1];
    }
    if (buffer.position + data.length > buffer.length) {
      buffer = new Buffer(this.bufferSize);
      buffer.position = 0;
      this.buffers.push(buffer);
      flush = true;
    }
    data.copy(buffer, buffer.position);
    buffer.position += data.length;
    if (flush) {
      this.flush();
    }
  }
  return this.buffers.length <= this.stackSize;
};

BufferStream.prototype.end = function(data, opt_encoding) {
  if (data) {
    this.write(data, opt_encoding);
  }
  this.writable = false;
  return this.flush();
};

/*
Read API
data    The 'data' event emits either a Buffer (by default) or a string if setEncoding() was used.
end    Emitted when the stream has received an EOF (FIN in TCP terminology). Indicates that no more 'data' events will happen. If the stream is also writable, it may be possible to continue writing.
error  Emitted if there was an error receiving data.
close  Emitted when the underlying file descriptor has been closed. Not all streams will emit this. (For example, an incoming HTTP request will not emit 'close'.)
*/


BufferStream.prototype.pause = function() {
  return this.paused = true;
};

BufferStream.prototype.resume = function() {
  this.paused = false;
  return this.flush();
};

module.exports = BufferStream;
